import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdtemp, readFile, rm } from 'node:fs/promises';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  EnvExampleWriter,
  JsonSchemaWriter,
  MarkdownWriter,
} from '@/output/writers';
import { createFinding, createFileRef } from '@/utils';
import type { ScanResult } from '@/types';

describe('Output Writers', () => {
  let tempDir: string;
  let mockScanResult: ScanResult;

  beforeEach(async () => {
    tempDir = await mkdtemp(join(tmpdir(), 'envaudit-writer-test-'));

    // Create mock scan result
    const findings = [
      createFinding('DATABASE_URL', 'ast', [
        createFileRef('/src/app.ts', 10, 5, 'Database connection')
      ], {
        required: true,
        isPublic: false,
      }),
      createFinding('NEXT_PUBLIC_API_URL', 'ast', [
        createFileRef('/src/config.ts', 5, 10, 'API configuration')
      ], {
        required: true,
        isPublic: true,
      }),
      createFinding('OPTIONAL_FEATURE', 'dotenv', [
        createFileRef('/.env.example', 15, 1, 'Feature flag')
      ], {
        required: false,
        defaultValue: 'false',
        isPublic: false,
      }),
    ];

    mockScanResult = {
      findings,
      stats: {
        totalFiles: 10,
        totalFindings: 3,
        findingsBySource: {
          ast: 2,
          dotenv: 1,
          docker: 0,
          gha: 0,
          shell: 0,
        },
        findingsByProvider: {
          ast: 2,
          dotenv: 1,
          yaml: 0,
          shell: 0,
        },
        scanTime: 150,
      },
      options: {
        includePatterns: [],
        excludePatterns: ['**/node_modules/**'],
        excludeProviders: [],
        publicPrefixes: ['NEXT_PUBLIC_'],
        followSymlinks: false,
        maxFileSize: 1024 * 1024,
        logLevel: 'info',
      },
      framework: 'nextjs',
      scannedAt: '2024-01-01T00:00:00.000Z',
    };
  });

  afterEach(async () => {
    await rm(tempDir, { recursive: true, force: true });
  });

  describe('EnvExampleWriter', () => {
    let writer: EnvExampleWriter;

    beforeEach(() => {
      writer = new EnvExampleWriter();
    });

    it('should have correct metadata', () => {
      expect(writer.name).toBe('env-example');
      expect(writer.fileExtension).toBe('.env.example');
    });

    it('should generate .env.example file with correct content', async () => {
      const outputPath = join(tempDir, '.env.example');
      await writer.write(mockScanResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      // Check header
      expect(content).toContain('# Environment Variables');
      expect(content).toContain('# Generated by EnvAudit');
      expect(content).toContain('# Generated at: 2024-01-01T00:00:00.000Z');

      // Check variables
      expect(content).toContain('DATABASE_URL=');
      expect(content).toContain('NEXT_PUBLIC_API_URL=');
      expect(content).toContain('OPTIONAL_FEATURE=false');

      // Check comments
      expect(content).toContain('# Required');
      expect(content).toContain('# Optional');
      expect(content).toContain('# Found in: src/app.ts:10');

      // Check statistics
      expect(content).toContain('# Total variables: 3');
      expect(content).toContain('# Files scanned: 10');
      expect(content).toContain('# Scan time: 150ms');
    });

    it('should generate appropriate placeholder values', async () => {
      const findings = [
        createFinding('API_URL', 'ast', [createFileRef('/src/api.ts', 1, 1)]),
        createFinding('DB_PORT', 'ast', [createFileRef('/src/db.ts', 1, 1)]),
        createFinding('SECRET_KEY', 'ast', [createFileRef('/src/auth.ts', 1, 1)]),
        createFinding('USER_EMAIL', 'ast', [createFileRef('/src/user.ts', 1, 1)]),
      ];

      const result = { ...mockScanResult, findings };
      const outputPath = join(tempDir, '.env.example');
      await writer.write(result, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      expect(content).toContain('API_URL=https://example.com');
      expect(content).toContain('DB_PORT=3000');
      expect(content).toContain('SECRET_KEY=your-secret-key');
      expect(content).toContain('USER_EMAIL=user@example.com');
    });

    it('should group variables by framework and source', async () => {
      const outputPath = join(tempDir, '.env.example');
      await writer.write(mockScanResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      // Should have framework section first
      expect(content).toContain('# Next.js Variables');
      expect(content).toContain('# Code Variables');
      expect(content).toContain('# Environment Files Variables');
    });
  });

  describe('JsonSchemaWriter', () => {
    let writer: JsonSchemaWriter;

    beforeEach(() => {
      writer = new JsonSchemaWriter();
    });

    it('should have correct metadata', () => {
      expect(writer.name).toBe('json-schema');
      expect(writer.fileExtension).toBe('.schema.json');
    });

    it('should generate valid JSON schema', async () => {
      const outputPath = join(tempDir, 'schema.json');
      await writer.write(mockScanResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');
      const schema = JSON.parse(content);

      // Check schema structure
      expect(schema.$schema).toBe('http://json-schema.org/draft-07/schema#');
      expect(schema.type).toBe('object');
      expect(schema.title).toBe('Environment Variables Schema');
      expect(schema.description).toContain('Generated by EnvAudit');

      // Check properties
      expect(schema.properties).toHaveProperty('DATABASE_URL');
      expect(schema.properties).toHaveProperty('NEXT_PUBLIC_API_URL');
      expect(schema.properties).toHaveProperty('OPTIONAL_FEATURE');

      // Check required array
      expect(schema.required).toContain('DATABASE_URL');
      expect(schema.required).toContain('NEXT_PUBLIC_API_URL');
      expect(schema.required).not.toContain('OPTIONAL_FEATURE');

      // Check metadata
      expect(schema['x-envaudit']).toBeDefined();
      expect(schema['x-envaudit'].framework).toBe('nextjs');
      expect(schema['x-envaudit'].stats).toBeDefined();
    });

    it('should include property metadata', async () => {
      const outputPath = join(tempDir, 'schema.json');
      await writer.write(mockScanResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');
      const schema = JSON.parse(content);

      const dbUrlProperty = schema.properties.DATABASE_URL;
      expect(dbUrlProperty.type).toBe('string');
      expect(dbUrlProperty['x-source']).toBe('ast');
      expect(dbUrlProperty['x-public']).toBe(false);
      expect(dbUrlProperty['x-files']).toHaveLength(1);

      const publicApiProperty = schema.properties.NEXT_PUBLIC_API_URL;
      expect(publicApiProperty['x-public']).toBe(true);

      const optionalProperty = schema.properties.OPTIONAL_FEATURE;
      expect(optionalProperty.default).toBe('false');
    });

    it('should generate appropriate patterns and examples', async () => {
      const findings = [
        createFinding('API_URL', 'ast', [createFileRef('/src/api.ts', 1, 1)]),
        createFinding('USER_EMAIL', 'ast', [createFileRef('/src/user.ts', 1, 1)]),
        createFinding('SERVER_PORT', 'ast', [createFileRef('/src/server.ts', 1, 1)]),
        createFinding('ENABLE_FEATURE', 'ast', [createFileRef('/src/feature.ts', 1, 1)]),
      ];

      const result = { ...mockScanResult, findings };
      const outputPath = join(tempDir, 'schema.json');
      await writer.write(result, outputPath);

      const content = await readFile(outputPath, 'utf-8');
      const schema = JSON.parse(content);

      // Check URL pattern
      const apiUrl = schema.properties.API_URL;
      expect(apiUrl.pattern).toBe('^https?://');
      expect(apiUrl.examples).toContain('https://api.example.com');

      // Check email pattern
      const userEmail = schema.properties.USER_EMAIL;
      expect(userEmail.pattern).toBe('^[^@]+@[^@]+\\.[^@]+$');
      expect(userEmail.examples).toContain('user@example.com');

      // Check port pattern
      const serverPort = schema.properties.SERVER_PORT;
      expect(serverPort.pattern).toBe('^[1-9][0-9]{0,4}$');
      expect(serverPort.examples).toContain('3000');

      // Check boolean pattern
      const enableFeature = schema.properties.ENABLE_FEATURE;
      expect(enableFeature.pattern).toBe('^(true|false)$');
      expect(enableFeature.examples).toContain('true');
    });
  });

  describe('MarkdownWriter', () => {
    let writer: MarkdownWriter;

    beforeEach(() => {
      writer = new MarkdownWriter();
    });

    it('should have correct metadata', () => {
      expect(writer.name).toBe('markdown');
      expect(writer.fileExtension).toBe('.md');
    });

    it('should generate comprehensive Markdown documentation', async () => {
      const outputPath = join(tempDir, 'README.md');
      await writer.write(mockScanResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      // Check structure
      expect(content).toContain('# Environment Variables Documentation');
      expect(content).toContain('## Summary');
      expect(content).toContain('## Code Variables');
      expect(content).toContain('## Variable Details');
      expect(content).toContain('## Configuration Guide');
      expect(content).toContain('## Framework Notes');

      // Check summary statistics
      expect(content).toContain('**Total Variables**: 3');
      expect(content).toContain('**Files Scanned**: 10');
      expect(content).toContain('**Scan Time**: 150ms');
      expect(content).toContain('**Framework**: Next.js');

      // Check variable table
      expect(content).toContain('| Variable | Required | Public | Default | Files |');
      expect(content).toContain('| `DATABASE_URL` |');
      expect(content).toContain('| `NEXT_PUBLIC_API_URL` |');
      expect(content).toContain('| `OPTIONAL_FEATURE` |');

      // Check detailed sections
      expect(content).toContain('### `DATABASE_URL`');
      expect(content).toContain('![Required](https://img.shields.io/badge/Required-red)');
      expect(content).toContain('![Public](https://img.shields.io/badge/Public-blue)');
      expect(content).toContain('![Source](https://img.shields.io/badge/Source-');

      // Check file references
      expect(content).toContain('[`src/app.ts`](src/app.ts) - Line 10');
    });

    it('should include framework-specific notes', async () => {
      const outputPath = join(tempDir, 'README.md');
      await writer.write(mockScanResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      // Should have Next.js specific notes
      expect(content).toContain('Public variables must be prefixed with `NEXT_PUBLIC_`');
      expect(content).toContain('Server-side variables are only available');
      expect(content).toContain('Restart the development server');
    });

    it('should handle different frameworks', async () => {
      const viteResult = { ...mockScanResult, framework: 'vite' as const };
      const outputPath = join(tempDir, 'README.md');
      await writer.write(viteResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      expect(content).toContain('**Framework**: Vite');
      expect(content).toContain('Public variables must be prefixed with `VITE_`');
    });

    it('should handle missing framework gracefully', async () => {
      const noFrameworkResult = { ...mockScanResult, framework: undefined };
      const outputPath = join(tempDir, 'README.md');
      await writer.write(noFrameworkResult, outputPath);

      const content = await readFile(outputPath, 'utf-8');

      // Should not have framework section
      expect(content).not.toContain('**Framework**:');
      expect(content).not.toContain('## Framework Notes');
    });
  });

  describe('Writer Interface Compliance', () => {
    it('should ensure all writers implement the OutputWriter interface', () => {
      const writers = [
        new EnvExampleWriter(),
        new JsonSchemaWriter(),
        new MarkdownWriter(),
      ];

      for (const writer of writers) {
        expect(writer).toHaveProperty('name');
        expect(writer).toHaveProperty('fileExtension');
        expect(writer).toHaveProperty('write');
        expect(typeof writer.write).toBe('function');

        // Verify name is a non-empty string
        expect(typeof writer.name).toBe('string');
        expect(writer.name.length).toBeGreaterThan(0);

        // Verify fileExtension starts with a dot
        expect(typeof writer.fileExtension).toBe('string');
        expect(writer.fileExtension.startsWith('.')).toBe(true);
      }
    });

    it('should have unique writer names', () => {
      const writers = [
        new EnvExampleWriter(),
        new JsonSchemaWriter(),
        new MarkdownWriter(),
      ];

      const names = writers.map(w => w.name);
      const uniqueNames = new Set(names);

      expect(uniqueNames.size).toBe(names.length);
    });

    it('should have unique file extensions', () => {
      const writers = [
        new EnvExampleWriter(),
        new JsonSchemaWriter(),
        new MarkdownWriter(),
      ];

      const extensions = writers.map(w => w.fileExtension);
      const uniqueExtensions = new Set(extensions);

      expect(uniqueExtensions.size).toBe(extensions.length);
    });
  });
});